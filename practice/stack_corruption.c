/*
 * Day: N/A
 * Date: 09/08/23
 *
 * Problem: How to corrupt the stack ?
 *  This was part of some interview for someone.
 *
 * ulimit -s : Shows the stack size in MB.
 * If you want to make it unlimited, need to provide, ulimit -s 16384
 *
 * Approach:
 *  1. Call a function foo() from main
 *  2. Create a local array arr[] in foo()
 *  3. Copy a bigger string than size of arr[]
 *  4. This should overwrite the return value of foo()
 *  5. Program is expected to crash here.
 *
 * Below warning is generated by compiler:
 *
 * stack_corruption.c: In function ‘foo’:
 * stack_corruption.c:27:5: warning: ‘__builtin_memcpy’ writing 71 bytes into a region of size 12 overflows the destination [-Wstringop-overflow=]
 *  27 |     strcpy(arr, "I_am_writing_a_more_than_12_bytes_array_so_that_it_corrupts_the_stack\n");
 *     |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * stack_corruption.c:25:10: note: destination object ‘arr’ of size 12
 *  25 |     char arr[12];
 *     |          ^~~
 *
 * Stack smashing after execution:
 *
 * *** stack smashing detected ***: terminated
 * Aborted (core dumped)
 *
 * Files: stack_corruption_demo.c
 */

#include <stdio.h>
#include <string.h>

void foo()
{
    printf("in foo\n");

    char arr[12];

    strcpy(arr, "I_am_writing_a_more_than_12_bytes_array_so_that_it_corrupts_the_stack\n");

    printf("arr = %s\n", arr);
}

int main(int argc, char *argv[])
{
    char stack[1024 * 1024 * 15];

    foo();

    printf("In main after foo(), if this line is printed means we returned from foo() successfully\n");

    return 0;
}